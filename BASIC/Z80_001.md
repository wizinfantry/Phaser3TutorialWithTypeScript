이 장에서는 Z80 칩이 기계 코드 번호, Z80 레지스터 및 일반적으로 사용되는 방식을 해석하는 방법과 다양한 유형의 어셈블러 명령어를 광범위하게 살펴 보겠습니다.
이러한 니모닉 명령어의 전체 목록은 부록에서 찾을 수 있습니다. 명령어 코드의 첫 번째 바이트를 기준으로 알파벳순 및 숫자 순으로 나열됩니다.
백과 사전처럼 각 Z80 명령어를 더 깊이 설명하는 몇 권의 책이 있지만, 이는 일반적인 참고 자료이며 MSX 범위와 같은 특정 마이크로에 대한 예를 표시하지 않습니다.
그러나 Z80 명령어 세트에 대한 더 자세한 정보가 필요한 경우 구매할 가치가 있습니다.

BASIC에는 'IF-THEN GOSUB'및 'IF THEN PRINT'와 같은 모든 미묘한 변형을 고려하여 200 개가 넘는 명령어가 있습니다.
Z80 기계어 코드는 거의 700 개에 달하지만 당황하지 마십시오. 대부분은 단순히 테마의 변형입니다.

이미 알고 있듯이 차이점은 하나의 BASIC 명령어가 인터프리터 내에서 여러 기계어 코드 명령어를 호출한다는 것입니다.
기계어 코드를 작성할 때 이러한 명령어를 직접 생성해야합니다.
물론 메모리의 ROM 섹션에있는 유용한 루틴을 호출 할 수 있습니다 (실제로이 책의 일부 데모 프로그램이 수행하는 것처럼).

예를 들어-BASIC에서 1에서 1000까지 카운트하는 방법은 무엇입니까? 아마:-
01 TIME=0
10 FOR I=1 TO 1000
20 NEXT
21 PRINT TIME
30 PRINT "ALL DONE"

좋습니다.하지만 FOR-NEXT 루프에 대해 몰랐다고 가정하십니까? 아마 이런 식으로 다룰 것입니다.
01 TIME=0
10 A=0
20 A=A+1
30 IF A<1000 THEN 20
31 PRINT TIME
40 PRINT "ALL DONE"

그러나 IF-THEN 구조에 대해서도 몰랐다고 가정합니다. 당신은 정말로 당신의 생각 모자를 써야 할 것입니다.
10 A=0
20 A=A+1
30 B=-1*(A<1000)-2*(A=1000)
40 ON B GOTO 20,50
50 PRINT TIME
51 PRINT "ALL DONE"

보시다시피, 가장 적합한 명령을 사용하지 않으면 프로그램이 길어지고 실행 시간이 더 오래 걸립니다.
마음대로 사용할 수있는 모든 명령을 알고 있으면 프로그램을 더 짧게 또는 더 빠르게 실행할 수 있으며 삶이 더 쉬워집니다.
일반적으로 기계 코드 프로그램은 '장거리'로 작성 될 때도 충분히 빠르게 실행되지만 체스 게임 프로그램과 같이 매우 많은 수의 반복적 인 작업이 관련 될 때
루프에서 몇 마이크로 초가 빠져 나가더라도 프로그램이 실행 중일 때 상당한 시간을 절약 할 수 있습니다.
그러나 이 책의 프로그램은 원칙을 보여주기 위해 작성되었으며 원하는 결과를 얻는 데 반드시 가장 빠르거나 가장 짧은 방법은 아닙니다.

## 모든 숫자는 무엇을 의미합니까?
아시다시피 기계 코딩은 숫자에 관한 것입니다. 숫자는 컴퓨터의 Z80 중앙 처리 장치에 대해 두 가지 중 하나를 의미 할 수 있습니다.
어떤 일을하라는 지시 또는 지시의 일부를 의미 할 수 있습니다. 또는 작업하거나 어떤 방식 으로든 사용할 정보를 의미 할 수 있습니다.
다행히 Z80은 이 숫자가 올바르게 작성된 프로그램에서 어떤 숫자를 나타내는 지 정확히 알고 그에 따라 작동합니다.

레지스터 A를 '7'값으로로드하라는 지시를받습니다 (레지스터에 대해서는 나중에 자세히 설명하겠습니다).
어셈블리 언어 니모닉에서이 명령어는 LD A, 7로 작성됩니다. 기계어 코드 언어에서 명령어는 두 개의 16 진수 '3E 07'로 표시됩니다.
Z80이 이들 중 첫 번째 것을 발견하면 "3E는 레지스터 A에 다음 번호를로드해야 함을 의미합니다."라고 표시됩니다.
7을 차지하여 레지스터 A에 넣은 다음 7 이후의 숫자를 검색하여 다음 명령어를 찾습니다.
예를 들어 두 개의 16 진수 '3E 3E'를 본다면 혼동하지 않을 것입니다.
이번에는 레지스터 A에 3E 16 진수 (십진수 62)를로드 한 다음 두 번째 3E 이후의 숫자에서 다음 지시.

정보의 각 단일 바이트는 0에서 FF 16 진수 (십진수 0에서 255)까지의 값을 가질 수 있습니다. 좀 더 자세히 살펴 보겠습니다.

바이트는 8 비트로 구성되며 각 비트는 이진 0 또는 1입니다. 따라서 이진수 11001001은 다음과 같이 나타낼 수 있습니다.
      Bit No: 76543210
Binary Value: 11001001

이진 표현에 '1'이 나타날 때마다 2를 해당 비트 번호의 거듭 제곱으로 올리고 결과를 더하면 이진 숫자의 십진수 값을 얻게됩니다.
따라서 위의 예를 사용하여 :-
    2 to the power 7 =128
    2 to the power 6 = 64
    2 to the power 3 = 8
    2 to the power 0 = 1 (any no. to the power 0=1)
                      ---
                      201

따라서 이진수 11001001은 10 진수로 201입니다.

이진수를 16 진수로 변환하려면 8 자리 숫자를 4 개의 그룹 ( '니블'이라고 함)으로 나눕니다. 그러므로:-
Nibble 'bit' no.: 3210 3210
    Binary value: 1100 1001
    Left side: 2^3 = 8  Right side: 2^3 = 8
               2^2 = 4              2^0 = 1
                    12                    9
10 진수 12 = C (16 진수)를 기억하면 이진수 11001001의 16 진수 값은 C9입니다.

## Z80이 2 바이트 숫자를 처리하는 방법
Z80에 대한 많은 명령은 'LD A, 7'에서와 같이 1 바이트가 아닌 2 바이트에서 작동하도록 지시합니다.
예를 들어, 어셈블리 명령어는 'LD HL, 49AFH'일 수 있습니다 (끝의 'H'는 어셈블러에게 49AF가 16 진수 숫자임을 알려줍니다).
2 바이트 숫자는 0-255에서 0-65535 (0-FFFF 16 진수)까지 표현할 수있는 10 진수 값을 증가시킵니다.
이는 컴퓨터의 메모리 위치를 지정하거나 가리키는 데 절대적으로 중요합니다.

LD HL, 49AFH 명령어에서 High 바이트, 49 (hex)는 H 레지스터로, Low byte AF (hex)는 L 레지스터로 이동합니다.
'직접'데이터와 함께 H 및 L 레지스터를로드하기위한 기계어 코드 명령어는 21 16 진수입니다.
Z80이 21 개의 16 진수를 명령어로 인식하면 NEXT 번호를 가져와 L 레지스터에 로드합니다.
맞습니다-L 레지스터. 그런 다음 다음 번호를 가져 와서 H 레지스터에로드합니다.
따라서 LD HL, 49AFH의 기계어 코드는 다음과 같습니다.
    21 AF 49 (hex)
실제 기계어 코드에서 두 정보 바이트의 순서가 어떻게 바뀌는 지 주목하십시오. 이제 이유를 알 수 있습니다.

어셈블러를 사용할 때이 점에 대해 걱정할 필요가 없습니다. 어셈블러가 자동으로 정렬합니다.
그러나 1 장에 표시된 것처럼 수동으로 기계어 코드를 입력하는 경우 위험에 처한 두 정보 바이트의 순서를 잊어 버리십시오.

말할 필요도없이 데이터와 함께 레지스터 쌍을로드 할 때 (나중에 레지스터 쌍에 대해 설명 함) Low 바이트는 항상 기계 코드 목록에서 High 바이트 앞에 나타납니다.
어셈블리 언어에서는 일반적인 방법으로 번호를 쓰고 어셈블러가 올바른 순서로 항목을 배치하도록합니다.

## Inside the Z80 chip
Z80 칩을 구성하는 요소에는 모든 (간단한) 산술 및 논리 기능을 수행하는 Arithmetic-Logic-Unit,
데이터가 올바르게 전달되고 디코딩되고 작동하는지 확인하는 '컨트롤 박스'가 포함됩니다.
순서 및 8 비트 (1 바이트) 및 16 비트 (2 바이트) 레지스터의 수.
혼동을 주기 위해 1 바이트 레지스터 쌍을 2 바이트 레지스터로 사용할 수도 있습니다.

## The Program Counter
먼저 프로그램 카운터 (PC) 2 바이트 레지스터를 살펴 보겠습니다. 이것은 NEXT 명령어의 주소를 보유합니다.
새 명령이 실행될 때마다 자동으로 업데이트됩니다. 그러나 보유하는 주소는 예를 들어 CALL 명령어 (BASIC의 GOSUB와 같은)에 의해 변경 될 수 있습니다.

이 경우 프로그램 카운터의 주소는 STACK에 따로 저장되고 CALLed 주소는 그 자리에 프로그램 카운터에 저장됩니다.
CALLed 루틴이 완료되면 RET (RETURN) 명령을 만나며 스택 맨 위에있는 2 바이트 숫자를 가져 와서 프로그램 카운터에 다시 넣습니다.
그런 다음 해당 주소에서 실행이 계속됩니다. 스택을 사용하는 경우 (사용하게 될 경우) RETurn 이후의 다음 명령어 주소는 스택 상단에서 가져옴을 기억하는 것이 중요합니다.
많은 프로그램이 무의식적으로 스택에 남아 있기 때문에 많은 프로그램이 거칠어졌습니다.
반면에 다음 (명백한) 명령어의 주소가 스택에 있다는 사실을 알고 있다는 사실은 예를 들어 전송할 때 유용 할 수 있습니다. 서브 루틴에 데이터.

다른 많은 명령어도 PC 레지스터에 영향을 미칩니다. 예를 들어 점프 명령어 (JP 또는 JR)가 있습니다.
그러나 대부분의 명령어에서 명령어의 길이 (정보 데이터 요소 포함)는 칩의 제어 시스템에 의해 PC에 추가되므로 다음 명령어를 찾을 위치를 알 수 있습니다.


## The Stack Pointer
또 다른 2 바이트 레지스터 인 SP (스택 포인터)는 스택의 맨 위를 추적합니다.
많은 명령을 사용하면 Z80뿐 아니라 스택을 사용할 수 있기 때문입니다. 스택 영역은 컴퓨터의 RAM 내에 있으며 스위치를 켤 때 ROM 루틴에 의해 주소가 설정됩니다.

스택에 대한 자신의 주소를 설정할 수 있지만 스택은 메모리에서 역방향으로 실행되며 후입 선출 시스템을 사용한다는 것을 기억해야합니다.
접시 더미로 생각하면 접시를 위에 놓거나 맨 위에서 떼어 낼 수 있지만 더미의 다른 곳에서는 접시를 만질 수 없습니다.

스택의 다른 점은 항상 2 바이트의 데이터를 수락하거나 전달한다는 것입니다.
따라서 11A0H, 22B0H 및 33C0H를 순서대로 스택에 놓고 스택 포인터가 F090으로 로드되면 다음과 같이 표시됩니다.
    Address     Contents
    F08B        C0
    F08C        33
    F08D        B0
    F08E        22
    F08F        A0
    F090        11
Z80의 스택 포인터는 33C0H 데이터의 마지막 (하위) 바이트를 가리 킵니다.
다른 2 바이트 데이터 (예 : 4567H)가 스택에 배치되면 스택 포인터가 1만큼 감소 (감소)되고
첫 번째 (높은) 바이트 45 16 진수가 이제 스택 포인터가 가리키는 주소에 배치됩니다 (F08A),
스택 포인터 주소가 다시 감소 된 다음 데이터의 하위 바이트 인 67 hex가 스택에 배치됩니다 (F089).
    Address     Contents
    F089        67
    F08A        45
    F08B        C0
    F08C        33
    F08D        B0
    F08E        22
    F08F        A0
    F090        11

스택에서 데이터를 가져 오면 시스템이 반대로 작동합니다.
이 예에서는 먼저 하위 바이트 (67 16 진수)가 제거되고 스택 포인터가 증가하고 상위 바이트 (45 16 진수)가 제거되고 스택 포인터가 다시 증가합니다.
이제 스택 포인터는 다시 한 번 33C0 16 진수 데이터의 하위 바이트를 가리 킵니다.
    Address     Contents
    F08B        C0
    F08C        33
    F08D        B0
    F08E        22
    F08F        A0
    F090        11

## The 8-Bit Registers
There are two sets of 8-bit Registers
        A ,F ,B ,C ,D ,E ,H ,L
    and A',F',B',C',D',E',H',L'
(F 및 F '레지스터는 각각의 A 레지스터 옆에 배치되었습니다. 이는 일반적으로 A 레지스터와 연결되어 있고 자체 기능이 모두 있기 때문입니다.)

한 번에 한 세트의 레지스터 만 사용할 수 있습니다. 왜 두 세트가 있습니까?
따라서 한 작업 중간에 '중지'하고 대체 세트로 전환하고 중간 작업을 수행 한 다음 다시 전환하여 원래 작업을 계속할 수 있습니다.
한 세트와 다른 세트간에 데이터를 전달하는 방법에는 여러 가지가 있습니다.

레지스터 B와 C, 레지스터 D와 E, 레지스터 H와 L은 2 바이트 데이터를 보유하는 레지스터 쌍으로도 사용됩니다.
몇 가지 명령에서 레지스터 A와 F도 쌍으로 처리됩니다.

## The A Register
A 레지스터는 누산기입니다. 거의 모든 액션이 발생합니다. 그것은 그랜드 센트럴 역과 같고 어떤 결과의 프로그램에서도 매우 바쁘게 유지됩니다.
실질적으로 모든 비교, 단일 바이트 덧셈 및 뺄셈 명령어, 그리고 많은 특수 '전송'및 '로드'명령어는 A 레지스터를 사용해야 합니다.

## The B and C Registers
여러 명령은 B 레지스터 또는 B 및 C 레지스터를 바이트 카운터로 함께 사용합니다. (BC = 바이트 카운터-기억하기 쉬움).
예를 들어 항상 레이블이 뒤에 와야 하는 DJNZ 어셈블리 명령을 사용하십시오.
이 명령어는 '레지스터 B에있는 값을 1만큼 감소시키고, 결과적으로 0이 아니면 라벨로 표시된 주소로 점프합니다'라고 말합니다.
BASIC의 FOR-NEXT 루프와 같으며 필요한 반복 횟수가 레지스터 B에 유지됩니다.
B가 0에 도달하면 처리는 다음 명령어로 계속됩니다. (니모닉 DJNZ = 감소 및 0이 아닌 점프에 유의하십시오).
유사한 명령 (예 : 'LDIR')은 레지스터 B와 C를 쌍으로 사용합니다.
-예를 들어 컴퓨터의 한 영역에서 다른 영역으로 크거나 작은 데이터 청크를 매우 빠르게 전송할 수 있습니다.
이러한 방식으로 전송 될 바이트 수는 레지스터 쌍 BC에 보관됩니다.
이러한 특별한 용도 외에도이 두 레지스터를 함께 사용하거나 사용자 고유의 요구 사항에 대해 독립적으로 사용할 수 있습니다.

## The D and E Registers
이것도 독립적으로 사용할 수 있지만 일부 Z80 명령어에서 함께 사용하여 목적지 주소를 정의합니다.
예를 들어, 데이터 블록 전송의 대상 주소 ('LDIR'명령 다시)는 레지스터 쌍 DE에서 가져옵니다. 물론 여기에 주소를 입력해야합니다.

## The H and L Registers
이 레지스터는 상당수의 Z80 명령어에 대해 쌍으로 사용됩니다. 예를 들어 'LDIR'명령에서 전송할 데이터의 시작 주소는 HL 레지스터의 내용에서 가져옵니다.
-그래서 거기에 두는 것을 잊지 마십시오. HL 레지스터를 사용하여 '데이터 영역을 가리킬 수있는 명령이 상당히 많다는 것을 알 수 있습니다.

## The F or 'Flag' Register
이것은 실제로 매우 중요한 레지스터입니다. 다른 8 비트 레지스터와 달리 일반적인 방식으로 데이터를로드 할 수 없습니다.
그 목적은 수행 된 논리 및 산술 연산의 플래그 결과를 유지하고 다른 명령의 경우 상태를 '플래그'하는 것입니다.
중요한 점은 일부 플래그가 예를 들어 조건부 점프, 호출 또는 반환을 제공하기 위해 '테스트'될 수 있다는 것입니다.

대부분의 지침은 플래그의 일부 또는 전체에 영향을 주지만, 플래그는 후속 지침의 영향을 받을 때까지 현재 상태에 남아 있습니다.
즉, 플래그의 상태는 영향을 준 명령어 다음에 여러 명령어를 테스트 할 수 있지만 중간 명령어가 해당 플래그에 영향을 미치지 않도록해야합니다.
이 기능은 필요한 코딩 양을 줄이는 데 도움이 될 수 있습니다. 예를 들어, '로드'명령어 중 두 개를 제외한 모든 명령어는 플래그에 전혀 영향을주지 않습니다.
따라서 특정 플래그의 상태에 따라 두 개의 서브 루틴 중 하나가 호출되고 두 서브 루틴이 시작시 동일한 '부하'를 요구하는 경우 조건부 테스트가 수행되기 전에 '부하'를 수행 할 수 있습니다.

플래그 레지스터의 특정 비트는 다음과 같이 특정 기능에 할당됩니다.
    Bit Number  :   7   6   5   4   3   2   1   0
    Function    :   S   Z   -   H   -   P/V N   C
    Testable    :   *   *               *       *
'Testable'행은 사용 가능한 지침을 사용하여 어떤 방식으로 든 테스트 할 수있는 플래그를 나타냅니다.
이제 각 1 비트 플래그의 기능을 살펴 보겠습니다.
#   The S or Sign Flag
이 플래그는 '시프트'를 포함하여 산술 또는 논리 연산의 결과에서 최상위 비트의 값을 '반복'합니다.
바이트가 A 레지스터로 전송되면 해당 바이트의 최상위 비트 값을 '반복'합니다.
대부분의 경우 비트 7 (가장 중요한)은 특정 조건을 나타내는 데 사용됩니다.
예를 들어 '2의 보수'표기법에서 (이 장의 뒷부분에서 간략하게 설명 함) 비트 7은 숫자의 부호를 나타냅니다.
즉, 이진수는 길이가 7 비트에 불과하지만 -128에서 +128까지를 나타냅니다.
이 예에서 비트 7은 숫자가 음수이면 'SET'( '1'과 같음)이고 숫자가 양수이면 'RESET'( '0'과 같음)입니다.
데이터 바이트의 비트 7은 프로그램이 프린터와 같은 입력 / 출력 장치와 '통신'할 때도 역할을 할 수 있습니다.
S 플래그를 사용하면 이러한 바이트의 비트 7을 테스트 할 수 있습니다.
많은 어셈블리 명령을 사용하면 'P'(양수입니까?) 또는 'M'(부정입니까?)을 추가하여 S 플래그를 테스트 할 수 있습니다.
예를 들어 JP (점프) 명령은 P- 'JP P, Label'을 추가하여 CONDITIONAL 점프로 전환 할 수 있습니다.
이것은 S 플래그를 테스트하고 이전 작업의 결과로 양수 (즉, 0과 같음)이면 점프가 발생합니다.
그렇지 않으면 다음 명령어로 처리가 계속됩니다.